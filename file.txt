// THIS IS MY KANBAN COMPONENT.
import { useEffect, useState } from "react";
import { useDispatch, useSelector } from "react-redux";
import {
  fetchTasks,
  createNewTask,
  updateExistingTask,
  removeTask,
  Task,
} from "@/store/taskSlice";
import { selectUser } from "@/store/userSlice";

const Kanban = () => {
  const dispatch = useDispatch();
  const tasks = useSelector((state: any) => state.tasks.tasks);
  const { user_id } = useSelector(selectUser);
  const [newTask, setNewTask] = useState<Partial<Task>>({
    task_name: "",
    description: "",
    difficulty: "medium",
    estimated_time: 60,
    assigned_to: user_id,
    column_id: "", // Assign appropriate column_id
    group_id: "", // Assign appropriate group_id if needed
    due_date: "",
    priority: "medium",
    progress: 0,
  });

  useEffect(() => {
    dispatch(fetchTasks());
  }, [dispatch]);

  const handleCreateTask = () => {
    dispatch(createNewTask(newTask));
    setNewTask({
      task_name: "",
      description: "",
      difficulty: "medium",
      estimated_time: 60,
      assigned_to: user_id,
      column_id: "",
      group_id: "",
      due_date: "",
      priority: "medium",
      progress: 0,
    });
  };

  const handleUpdateTask = (task_id: string, taskData: Partial<Task>) => {
    dispatch(updateExistingTask({ task_id, taskData }));
  };

  const handleDeleteTask = (task_id: string) => {
    dispatch(removeTask(task_id));
  };

  return (
    <div>
      <h1>Kanban Board</h1>
      <div>
        <input
          type="text"
          placeholder="Task Name"
          value={newTask.task_name}
          onChange={(e) =>
            setNewTask({ ...newTask, task_name: e.target.value })
          }
        />
        <textarea
          placeholder="Description"
          value={newTask.description}
          onChange={(e) =>
            setNewTask({ ...newTask, description: e.target.value })
          }
        ></textarea>
        <button onClick={handleCreateTask}>Add Task</button>
      </div>
      <ul>
        {tasks.map((task: Task) => (
          <li key={task.task_id}>
            <h3>{task.task_name}</h3>
            <p>{task.description}</p>
            <button
              onClick={() =>
                handleUpdateTask(task.task_id, {
                  task_name: task.task_name + " Updated",
                })
              }
            >
              Edit
            </button>
            <button onClick={() => handleDeleteTask(task.task_id)}>
              Delete
            </button>
          </li>
        ))}
      </ul>
    </div>
  );
};

export default Kanban;

// THIS IS MY taskSlice.ts STORE IN REDUX
import { createSlice, PayloadAction, createAsyncThunk } from "@reduxjs/toolkit";
import { createTask, getTasks, updateTask, deleteTask } from "@/api/taskApi"

export type Task = {
  task_id: string;
  task_name: string;
  description: string;
  difficulty: string;
  estimated_time: number;
  assigned_to: string;
  column_id: string;
  group_id: string;
  due_date: string;
  priority: string;
  progress: number;
};

type TaskState = {
  tasks: Task[];
  loading: boolean;
  error: string | null;
};

const initialState: TaskState = {
  tasks: [],
  loading: false,
  error: null,
};

export const fetchTasks = createAsyncThunk("tasks/fetchTasks", async () => {
  const response = await getTasks();
  return response;
});

export const createNewTask = createAsyncThunk(
  "tasks/createNewTask",
  async (taskData: Partial<Task>) => {
    const response = await createTask(taskData);
    return response;
  }
);

export const updateExistingTask = createAsyncThunk(
  "tasks/updateExistingTask",
  async ({ task_id, taskData }: { task_id: string; taskData: Partial<Task> }) => {
    const response = await updateTask(task_id, taskData);
    return response;
  }
);

export const removeTask = createAsyncThunk("tasks/removeTask", async (task_id: string) => {
  const response = await deleteTask(task_id);
  return response;
});

const taskSlice = createSlice({
  name: "tasks",
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchTasks.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchTasks.fulfilled, (state, action: PayloadAction<Task[]>) => {
        state.tasks = action.payload;
        state.loading = false;
      })
      .addCase(fetchTasks.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message || "Failed to fetch tasks";
      })
      .addCase(createNewTask.fulfilled, (state, action: PayloadAction<Task>) => {
        state.tasks.push(action.payload);
      })
      .addCase(updateExistingTask.fulfilled, (state, action: PayloadAction<Task>) => {
        const index = state.tasks.findIndex((task) => task.task_id === action.payload.task_id);
        if (index !== -1) {
          state.tasks[index] = action.payload;
        }
      })
      .addCase(removeTask.fulfilled, (state, action: PayloadAction<{ task_id: string }>) => {
        state.tasks = state.tasks.filter((task) => task.task_id !== action.payload.task_id);
      });
  },
});

export default taskSlice.reducer;

// THIS IS MY taskApi.ts FILE
import axiosInstance from "./axiosInstance";

const createTask = async (taskData: object) => {
  try {
    const response = await axiosInstance.post("/task", taskData);
    return response.data;
  } catch (err) {
    console.error("Error creating task:", err);
    throw err;
  }
};

const getTasks = async () => {
  try {
    const response = await axiosInstance.get("/task");
    return response.data;
  } catch (err) {
    console.error("Error fetching tasks:", err);
    throw err;
  }
};

const updateTask = async (task_id: string, taskData: object) => {
  try {
    const response = await axiosInstance.put(`/tasks/${task_id}`, taskData);
    return response.data;
  } catch (err) {
    console.error("Error updating task:", err);
    throw err;
  }
};

const deleteTask = async (task_id: string) => {
  try {
    const response = await axiosInstance.delete(`/tasks/${task_id}`);
    return response.data;
  } catch (err) {
    console.error("Error deleting task:", err);
    throw err;
  }
};

export { createTask, getTasks, updateTask, deleteTask };

// THIS IS MY taskController.js
import { Task } from "../models/association.js";

const createTask = async (req, res) => {
  try {
    const task = await Task.create(req.body);
    res.status(201).json(task);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

const getTasks = async (req, res) => {
  try {
    const tasks = await Task.findAll();
    res.json(tasks);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

const updateTask = async (req, res) => {
  try {
    const { task_id } = req.params;
    await Task.update(req.body, { where: { task_id } });
    res.json({ message: "Task updated" });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

const deleteTask = async (req, res) => {
  try {
    const { task_id } = req.params;
    await Task.destroy({ where: { task_id } });
    res.json({ message: "Task deleted" });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

export { createTask, getTasks, updateTask, deleteTask };

// THIS IS MY taskRouter.js
import { Router } from "express";
import {
  createTask,
  updateTask,
  deleteTask,
  getTasks,
} from "../controllers/taskController.js";
const taskRouter = new Router();

taskRouter.post("/", createTask);
taskRouter.get("/", getTasks);
taskRouter.put("/:task_id", updateTask);
taskRouter.delete("/:task_id", deleteTask);

export default taskRouter;


// THIS IS MY TASK MODEL
import { DataTypes } from "sequelize";
import sequelize from "../config/database.js";

const Task = sequelize.define(
  "task",
  {
    task_id: {
      type: DataTypes.UUID,
      defaultValue: DataTypes.UUIDV4,
      primaryKey: true,
      allowNull: false,
    },
    task_name: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    description: {
      type: DataTypes.TEXT,
      allowNull: true,
    },
    difficulty: {
      type: DataTypes.ENUM("easy", "medium", "hard"),
      allowNull: false,
    },
    estimated_time: {
      type: DataTypes.INTEGER, // In minutes or hours
      allowNull: false,
    },
    assigned_to: {
      type: DataTypes.UUID,
      allowNull: true,
      references: {
        model: "users",
        key: "user_id",
      },
      onUpdate: "CASCADE",
      onDelete: "SET NULL",
    },
    column_id: {
      type: DataTypes.UUID,
      allowNull: false,
      references: {
        model: "taskColumns",
        key: "column_id",
      },
      onUpdate: "CASCADE",
      onDelete: "CASCADE",
    },
    group_id: {
      type: DataTypes.UUID,
      allowNull: false,
      references: {
        model: "groups",
        key: "group_id",
      },
      onUpdate: "CASCADE",
      onDelete: "CASCADE",
    },
    due_date: {
      type: DataTypes.DATE,
      allowNull: true,
    },
    priority: {
      type: DataTypes.ENUM("low", "medium", "high"),
      allowNull: true,
    },
    progress: {
      type: DataTypes.INTEGER,
      allowNull: true,
      defaultValue: 0,
    },
  },
  {
    tableName: "tasks",
    timestamps: true,
  }
);

export default Task;
fix this from top to bottom keep this in the file they are supposed to be and make this all work at once right now think very deep